#include "curve25519-yx.h"
#include <time.h>
#include <sys/time.h>
#include <emmintrin.h>
#include <omp.h>

/* gcc testavx.c -mavx512dq -mavx512vbmi -mavx512ifma -O3 -fopenmp */

// #include <assert.h>
// #include <unistd.h>
// #include <sys/types.h>
// #include <sys/mman.h>
// #include <sys/syscall.h>
// #include <linux/perf_event.h>

// static long long cpucycles(void)
// {
//   static int rdpmcworks = 1;
//   long long result;

//   while (rdpmcworks) {
//     static int fdperf = -1;
//     static struct perf_event_mmap_page *buf = 0;
// #ifdef THREADING
//     unsigned int seq;
//     long long index;
//     long long offset;
// #endif

//     if (fdperf == -1) {
//       static struct perf_event_attr attr;
//       memset(&attr,0,sizeof attr);
//       attr.type = PERF_TYPE_HARDWARE;
//       attr.config = PERF_COUNT_HW_CPU_CYCLES;
//       attr.exclude_kernel = 1;
//       fdperf = syscall(__NR_perf_event_open, &attr, 0, -1, -1, 0);
//       if (fdperf == -1) {
//         rdpmcworks = 0;
//         break;
//       }
//       buf = mmap(NULL, sysconf(_SC_PAGESIZE), PROT_READ, MAP_SHARED, fdperf, 0);
//       if (buf == 0) {
//         rdpmcworks = 0;
//         break;
//       }
//     }

// #ifdef THREADING
//     do {
//       seq = buf->lock;
//       asm volatile("" ::: "memory");
//       index = buf->index;
//       offset = buf->offset;
//       asm volatile("rdpmc;shlq $32,%%rdx;orq %%rdx,%%rax"
//         : "=a"(result) : "c"(index-1) : "%rdx");
//       asm volatile("" ::: "memory");
//     } while (buf->lock != seq);

//     result += offset;
// #else
//     asm volatile("rdpmc;shlq $32,%%rdx;orq %%rdx,%%rax"
//       : "=a"(result) : "c"(0) : "%rdx");
// #endif

//     result &= 0xffffffffffff;
//     return result;
//   }

//   asm volatile(".byte 15;.byte 49;shlq $32,%%rdx;orq %%rdx,%%rax"
//     : "=a" (result) ::  "%rdx");
//   return result;
// }

static void
edassert_die(const unsigned char *a, const unsigned char *b, size_t len, int round, const char *failreason) {
	size_t i;
	if (round > 0)
		printf("round %d, %s\n", round, failreason);
	else
		printf("%s\n", failreason);
	printf("want: "); for (i = 0; i < len; i++) printf("%02x,", a[i]); printf("\n");
	printf("got : "); for (i = 0; i < len; i++) printf("%02x,", b[i]); printf("\n");
	printf("diff: "); for (i = 0; i < len; i++) if (a[i] ^ b[i]) printf("%02x,", a[i] ^ b[i]); else printf("  ,"); printf("\n\n");
	exit(1);
}

static void
edassert_equal(const unsigned char *a, const unsigned char *b, size_t len, const char *failreason) {
	if (memcmp(a, b, len) == 0)
		return;
	printf("a: "); for (int i = 0; i < 32; i++) printf("%02x,", a[i]); printf("\n");
    printf("b: "); for (int i = 0; i < 32; i++) printf("%02x,", b[i]); printf("\n");
    edassert_die(a, b, len, -1, failreason);
}

int main() {
    uint8_t pa_scalar[8][32] = {
        {0xe1, 0xca, 0xaa, 0x08, 0x4a, 0xb7, 0xc8, 0x2d, 0x01, 0x51, 0xfe, 0x08, 0x4a, 0x11, 0x11, 0x30, 0x51, 0xfe, 0x99, 0x08, 0x4a, 0x11, 0x30, 0x2d, 0x01, 0x51, 0xfe, 0x99, 0xc2, 0xb6, 0x39, 0xd1},
        {0xe2, 0xca, 0xaa, 0x08, 0x4a, 0xb7, 0xc8, 0x2d, 0x01, 0x51, 0xfe, 0x08, 0x4a, 0x11, 0x11, 0x30, 0x51, 0xfe, 0x99, 0x08, 0x4a, 0x11, 0x30, 0x2d, 0x01, 0x51, 0xfe, 0x99, 0xc2, 0xb6, 0x39, 0xd2},
        {0xe3, 0xca, 0xaa, 0x08, 0x4a, 0xb7, 0xc8, 0x2d, 0x01, 0x51, 0xfe, 0x08, 0x4a, 0x11, 0x11, 0x30, 0x51, 0xfe, 0x99, 0x08, 0x4a, 0x11, 0x30, 0x2d, 0x01, 0x51, 0xfe, 0x99, 0xc2, 0xb6, 0x39, 0xd3},
        {0xe4, 0xca, 0xaa, 0x08, 0x4a, 0xb7, 0xc8, 0x2d, 0x01, 0x51, 0xfe, 0x08, 0x4a, 0x11, 0x11, 0x30, 0x51, 0xfe, 0x99, 0x08, 0x4a, 0x11, 0x30, 0x2d, 0x01, 0x51, 0xfe, 0x99, 0xc2, 0xb6, 0x39, 0xd4},
        {0xe5, 0xca, 0xaa, 0x08, 0x4a, 0xb7, 0xc8, 0x2d, 0x01, 0x51, 0xfe, 0x08, 0x4a, 0x11, 0x11, 0x30, 0x51, 0xfe, 0x99, 0x08, 0x4a, 0x11, 0x30, 0x2d, 0x01, 0x51, 0xfe, 0x99, 0xc2, 0xb6, 0x39, 0xd5},
        {0xe6, 0xca, 0xaa, 0x08, 0x4a, 0xb7, 0xc8, 0x2d, 0x01, 0x51, 0xfe, 0x08, 0x4a, 0x11, 0x11, 0x30, 0x51, 0xfe, 0x99, 0x08, 0x4a, 0x11, 0x30, 0x2d, 0x01, 0x51, 0xfe, 0x99, 0xc2, 0xb6, 0x39, 0xd6},
        {0xe7, 0xca, 0xaa, 0x08, 0x4a, 0xb7, 0xc8, 0x2d, 0x01, 0x51, 0xfe, 0x08, 0x4a, 0x11, 0x11, 0x30, 0x51, 0xfe, 0x99, 0x08, 0x4a, 0x11, 0x30, 0x2d, 0x01, 0x51, 0xfe, 0x99, 0xc2, 0xb6, 0x39, 0xd7},
        {0xe8, 0xca, 0xaa, 0x08, 0x4a, 0xb7, 0xc8, 0x2d, 0x01, 0x51, 0xfe, 0x08, 0x4a, 0x11, 0x11, 0x30, 0x51, 0xfe, 0x99, 0x08, 0x4a, 0x11, 0x30, 0x2d, 0x01, 0x51, 0xfe, 0x99, 0xc2, 0xb6, 0x39, 0xd8},
    };
    uint8_t pa_scalar_1[8][32] = {
        {0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
    };
    uint8_t testL[8][32] = {
        {0xED, 0xD3, 0xF5, 0x5C, 0x1A, 0x63, 0x12, 0x58, 0xD6, 0x9C, 0xF7, 0xA2, 0xDE, 0xF9, 0xDE, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10},
        {0xED, 0xD3, 0xF5, 0x5C, 0x1A, 0x63, 0x12, 0x58, 0xD6, 0x9C, 0xF7, 0xA2, 0xDE, 0xF9, 0xDE, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10},
        {0xED, 0xD3, 0xF5, 0x5C, 0x1A, 0x63, 0x12, 0x58, 0xD6, 0x9C, 0xF7, 0xA2, 0xDE, 0xF9, 0xDE, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10},
        {0xED, 0xD3, 0xF5, 0x5C, 0x1A, 0x63, 0x12, 0x58, 0xD6, 0x9C, 0xF7, 0xA2, 0xDE, 0xF9, 0xDE, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10},
        {0xED, 0xD3, 0xF5, 0x5C, 0x1A, 0x63, 0x12, 0x58, 0xD6, 0x9C, 0xF7, 0xA2, 0xDE, 0xF9, 0xDE, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10},
        {0xED, 0xD3, 0xF5, 0x5C, 0x1A, 0x63, 0x12, 0x58, 0xD6, 0x9C, 0xF7, 0xA2, 0xDE, 0xF9, 0xDE, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10},
        {0xED, 0xD3, 0xF5, 0x5C, 0x1A, 0x63, 0x12, 0x58, 0xD6, 0x9C, 0xF7, 0xA2, 0xDE, 0xF9, 0xDE, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10},
        {0xED, 0xD3, 0xF5, 0x5C, 0x1A, 0x63, 0x12, 0x58, 0xD6, 0x9C, 0xF7, 0xA2, 0xDE, 0xF9, 0xDE, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10}
    };
    uint8_t testScalar[8][32] = {
        {0xED, 0xD3, 0xF5, 0x5C, 0x1A, 0x63, 0x12, 0x58, 0xD6, 0x9C, 0xF7, 0xA2, 0xDE, 0xF9, 0xDE, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10},
        {0xED, 0xD3, 0xF5, 0x5C, 0x1A, 0x63, 0x12, 0x58, 0xD6, 0x9C, 0xF7, 0xA2, 0xDE, 0xF9, 0xDE, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10},
        {0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0xED, 0xD3, 0xF5, 0x5C, 0x1A, 0x63, 0x12, 0x58, 0xD6, 0x9C, 0xF7, 0xA2, 0xDE, 0xF9, 0xDE, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10},
        {0xED, 0xD3, 0xF5, 0x5C, 0x1A, 0x63, 0x12, 0x58, 0xD6, 0x9C, 0xF7, 0xA2, 0xDE, 0xF9, 0xDE, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10},
        {0xED, 0xD3, 0xF5, 0x5C, 0x1A, 0x63, 0x12, 0x58, 0xD6, 0x9C, 0xF7, 0xA2, 0xDE, 0xF9, 0xDE, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10},
        {0xED, 0xD3, 0xF5, 0x5C, 0x1A, 0x63, 0x12, 0x58, 0xD6, 0x9C, 0xF7, 0xA2, 0xDE, 0xF9, 0xDE, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10}
    };
    uint64_t scalar[4][8];
    __ALIGN64 U64 scalarvector[4];
    uint8_t output1[125][8][32];
    uint8_t output2[125][8][32];
    uint8_t testData[1250000][8][32];
    U64 testvector[5];
    U64 testvectorone[5];
    uint64_t out[8][4];

    uint8_t out1[8][32];
    uint8_t out2[8][32];
    uint8_t tests[8][32];
    uint8_t output[8][32];

    int64_t cycle[64];

    for(int i = 0; i < 1250000; ++i)
    {
        for(int j = 0; j < 8; ++j)
        {
            for(int k = 0; k < 32; ++k)
            {
                testData[i][j][k] = testScalar[j][k];
            }
            testData[i][j][i % 32] ^= (i % 64);
        }
    }


    uint8_t key[32] = {
        0xe4, 0xca, 0xaa, 0x08, 0x4a, 0xb7, 0xc8, 0x2d, 0x01, 0x51, 0xfe, 0x08, 0x4a, 0x11, 0x11, 0x30, 0x51, 0xfe, 0x99, 0x08, 0x4a, 0x11, 0x30, 0x2d, 0x01, 0x51, 0xfe, 0x99, 0xc2, 0xb6, 0x39, 0xd4};

    curved25519 privateAlice = {
        0xe8, 0xca, 0xaa, 0x08, 0x4a, 0xb7, 0xc8, 0x2d, 0x01, 0x51, 0xfe, 0x08, 0x4a, 0x11, 0x11, 0x30, 
        0x51, 0xe8, 0xca, 0xaa, 0x08, 0x4a, 0xb7, 0x2d, 0x01, 0x51, 0xfe, 0x99, 0xc2, 0xb6, 0x39, 0x7a
    };

	curved25519 privateBob = {
        0xe8, 0x2d, 0x01, 0x51, 0xfe, 0xb7, 0xc8, 0x2d, 0x01, 0x51, 0xfe, 0x08, 0x4a, 0x11, 0x11, 0x30, 
        0x51, 0xfe, 0x99, 0x08, 0x4a, 0x11, 0x30, 0x2d, 0x01, 0x51, 0xfe, 0x99, 0xc2, 0xb6, 0x39, 0x7a
    };

	curved25519 privateAliceInv = {
        0xc1, 0xed, 0xdf, 0x39, 0x65, 0xb3, 0xf2, 0xc0, 0xc4, 0xb5, 0xb0, 0xcc, 0x30, 0x75, 0xa2, 0xd8,
		0x48, 0x76, 0x2b, 0x1f, 0x4a, 0x54, 0xf6, 0x00, 0xda, 0x83, 0x69, 0x74, 0xe6, 0xdf, 0x3f, 0x06
    };

    curved25519 testNum = {
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };

    curved25519 key1, key2;

    uint64_t a = 0xFFFFFFFFFFFFFFFF;
    U64 testright = {a,a,a,a,a,a,a,a};
    printavxone(testright);
    testright = _mm512_srli_epi64(testright, 63);
    printavxone(testright);

    omp_set_num_threads(4);

	struct timeval tv1, tv2;
	int ss, mss, uss;
    
    clamp(key1, privateBob);
    clamp(key2, privateAlice);

    int i = 0;
    int j, k;

	gettimeofday(&tv1, NULL);
    // curve25519_scalarmult_basepoint_comb_mb((uint8_t **)output, (const uint8_t *const *)testScalar);
	#pragma omp parallel 
    {
       #pragma omp for schedule(static, 4)
    for(i = 0; i < 125000; ++i)
    {
        for(j = 0; j < 6; ++j)
        {
            for(k = 0; k < 32; ++k)
            {
                tests[j][k] = testScalar[j][k];
            }
            tests[j][i % 32] ^= (i % 64 + i);
        }
    
// cycle[(2 * i) % 64] = cpucycles();
    //    x25519_scalarmult_mb8(out1, privateBob, tests);
// curve25519_scalarmult_basepoint_comb_mb((uint8_t **)out1, (const uint8_t *const *)tests);
// cycle[(2 * i + 1) % 64] = cpucycles();
// cycle[(2 * i) % 64] = cpucycles();
        ed25519_basemult_mb8(out1, privateBob, tests);
// cycle[(2 * i + 1) % 64] = cpucycles();
        // printf("output1: "); for(j = 0; j < 8; ++j) {for (k = 0; k < 32; k++) printf("%02x,", out1[j][k]); printf("\n");} printf("\n");
        
        // ed25519_basemult_mb8(out2, privateAlice, tests);
        // // printf("output21: "); for(j = 0; j < 8; ++j) {for (k = 0; k < 32; k++) printf("%02x,", output2[i][j][k]); printf("\n");} printf("\n");
        // x25519_scalarmult_mb8(out2, privateBob, out2);
        // // printf("output22: "); for(j = 0; j < 8; ++j) {for (k = 0; k < 32; k++) printf("%02x,", output2[i][j][k]); printf("\n");} printf("\n");
        // x25519_scalarmult_mb8(out2, privateAliceInv, out2);
        // // printf("output23: "); for(j = 0; j < 8; ++j) {for (k = 0; k < 32; k++) printf("%02x,", out2[j][k]); printf("\n");} printf("\n");

        // for(j = 0; j < 8; ++j)
        // {
        //     // printf("No.%d \n", j);
        //     edassert_equal(out1[j], out2[j], sizeof(curved25519), "Encrypt result failed to generate correct value");
        // }
        
    }
    }

    

    gettimeofday(&tv2, NULL);
	ss = tv2.tv_sec - tv1.tv_sec;
	mss = tv2.tv_sec*1000 + tv2.tv_usec/1000 - (tv1.tv_sec*1000 + tv1.tv_usec/1000);
	uss = tv2.tv_sec*1000000 + tv2.tv_usec - (tv1.tv_sec*1000000 + tv1.tv_usec);
    printf("程序执行时间为：%ds, %dms, %dus\n", ss, mss, uss);

    printavxone(LFACTOR);

    // for(int i = 0; i < 8; ++i)
    // {
    //     for(int j = 0; j < 32; ++j)
    //     {
    //         printf("%02x ", output[23][i][j]);
    //     }
    //     printf("\n");
    // }
    long sum = 0;
    printf("cycles");
  for (i = 0;i < 32;++i)
    sum += cycle[2*i+1]-cycle[2*i];
    printf(" %ld",sum / 32);
  printf("\n");

    uint64_t NN = 10000000;
    int s1 = 0, s2 = 0, s3 = 0, s4 = 0;
    int s5 = 0, s6 = 0, s7 = 0, s8 = 0;
    printf("s1: %d, s2: %d, s3: %d, s4: %d, \n", s1, s2, s3, s4);
    
    sum = 0;
    t1 = cpucycles();
    for(int i = 1; i <= NN; i += 1)
    {
        sum += i;     sum &= 0xffffffff;
    }
    t2 = cpucycles();
    printf("sum0: %ld, %ld\n", t2 - t1, sum);
    
    sum = 0;
    t1 = cpucycles();
    for(int i = 1; i <= NN; i += 4)
    {
        sum += i;     sum &= 0xffffffff;
        sum += i + 1; sum &= 0xffffffff;
        sum += i + 2; sum &= 0xffffffff;
        sum += i + 3; sum &= 0xffffffff;
        // sum += i + 4; sum &= 0xffffffff;
        // sum += i + 5; sum &= 0xffffffff;
        // sum += i + 6; sum &= 0xffffffff;
        // sum += i + 7; sum &= 0xffffffff;

        // sum += i + 8;  sum &= 0xffffffff;
        // sum += i + 9;  sum &= 0xffffffff;
        // sum += i + 10; sum &= 0xffffffff;
        // sum += i + 11; sum &= 0xffffffff;
        // sum += i + 12; sum &= 0xffffffff;
        // sum += i + 13; sum &= 0xffffffff;
        // sum += i + 14; sum &= 0xffffffff;
        // sum += i + 15; sum &= 0xffffffff;
    }
    t2 = cpucycles();
    printf("sum1: %ld, %ld\n", t2 - t1, sum);

    sum = 0;
    t1 = cpucycles();
    for(int i = 1; i <= NN; i += 4)
    {
        s1 += i;     s1 &= 0xffffffff;
        s2 += i + 1; s2 &= 0xffffffff;
        s3 += i + 2; s3 &= 0xffffffff;
        s4 += i + 3; s4 &= 0xffffffff;
        // s1 += i + 4; s1 &= 0xffffffff;
        // s2 += i + 5; s2 &= 0xffffffff;
        // s3 += i + 6; s3 &= 0xffffffff;
        // s4 += i + 7; s4 &= 0xffffffff;
    }
    sum += s1; sum &= 0xffffffff;
    sum += s2; sum &= 0xffffffff;
    sum += s3; sum &= 0xffffffff;
    sum += s4; sum &= 0xffffffff;
    t2 = cpucycles();
    printf("sum4: %ld, %ld\n", t2 - t1, sum);
    
    s1 = 0, s2 = 0, s3 = 0, s4 = 0;
    printf("s1: %d, s2: %d, s3: %d, s4: %d, \n", s1, s2, s3, s4);
    sum = 0;
    t1 = cpucycles();
    for(int i = 1; i <= NN; i += 8)
    {
        s1 += i;     s1 &= 0xffffffff;
        s2 += i + 1; s2 &= 0xffffffff;
        s3 += i + 2; s3 &= 0xffffffff;
        s4 += i + 3; s4 &= 0xffffffff;
        s5 += i + 4; s5 &= 0xffffffff;
        s6 += i + 5; s6 &= 0xffffffff;
        s7 += i + 6; s7 &= 0xffffffff;
        s8 += i + 7; s8 &= 0xffffffff;
    }
    sum += s1; sum &= 0xffffffff;
    sum += s2; sum &= 0xffffffff;
    sum += s3; sum &= 0xffffffff;
    sum += s4; sum &= 0xffffffff;
    sum += s5; sum &= 0xffffffff;
    sum += s6; sum &= 0xffffffff;
    sum += s7; sum &= 0xffffffff;
    sum += s8; sum &= 0xffffffff;
    t2 = cpucycles();
    printf("sum8: %ld, %ld\n", t2 - t1, sum);

    return 0;
}